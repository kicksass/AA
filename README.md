[고객 상황] K Software는 전 세계 판매를 목적으로 Cloud 환경에 게임 판매 사이트를 구축하려 한다. 사용자 성향 및 SNS 분석을 통해 게임을 추천하고, 이를 통해 구매를 유도할 계획이다. 사용자는 사이트를 통해 게임을 다운로드하여 구입, 관리할 수 있으며, 채팅, 방송 및 다양한 커뮤니티 기능을 통해서 다른 사용자와 소통할 수 있다. 사이트의 다양한 기능은 POC 진행 후 고객 Feedback에 따라 확대를 진행하는 방식으로 사업 영역을 넓혀가려고 한다.
[업무 요건] • 전 세계 대상 게임 판매를 목적으로 시스템을 구축하려 한다. • 사용자 증감에 따라서 시스템 확장이 유연해야 한다. • 업무 특성에 맞는 최적의 개발 언어와 DB를 선택하여 구축한다. (커뮤니티나 채팅은 빠른 응답, 결제와 분석은 안정성) • 자연재해나 시스템의 물리적인 결함 상황에서도 시스템은 운영이 되어야 한다. • 프로모션은 수시로 진행되며, 운영 중에도 적용이 쉽게 되면서, 다른 서비스에 영향이 없어야 한다. • 프로모션이 진행되면 사용자 수가 평소보다 급격히 증가할 것으로 예상된다. • 가입과 인증을 쉽게 하기 위해 각 국가의 소셜 로그인 기능을 지속적으로 추가하여, 사용자 가입을 유도한다. • 사용자가 게임을 직접 검색할 수도 있고, 시스템이 사용자의 개인 성향에 따라서 맞춤형 게임을 추천할 수 있어야 한다. • 추천은 게임의 평점, 최근 플레이한 게임, 커뮤니티 및 각종 SNS 사이트의 내용 등을 고려한다. • 다양한 결제 방법을 선택할 수 있고, 각 국가의 대표적인 결제 수단이 반영되어야 한다. • 사용자는 다양한 SNS를 통하여 본인의 게임 내용을 쉽게 공유할 수 있어야 한다. • 특정 지역에서는 계약 및 법률 규정에 따라서 판매 및 이용이 불가능하도록 해야 한다. • 모든 구매를 포함한 사용자의 활동 정보는 분석을 위하여 사용되고, 다시 사용자에게 feedback되어야 한다.

[업무 시나리오 1] - 신규 출시 게임 예약 ① 신규 게임 출시가 확정되면 담당자는 게임을 등록한다. ② 신규 게임이 출시되면 해당 게임 유형 선호도가 높은 사용자에게 추천 시스템을 통해 이메일을 자동 발송한다. ③ 사용자는 메일 예약 링크 또는 사이트 검색을 통해 예약 주문을 진행한다. ④ 신규 게임의 서비스 대상 국가와 사용자의 거주 국가가 일치하지 않는 경우에는 예약을 할 수 없다. ⑤ 사용자는 결제 방식을 선택하고 결제를 진행한다. ⑥ 결제 금액은 담당자가 등록한 할인 금액이 적용된다. ⑦ 결제는 해당 국가에서 지원하는 신용카드와 간편 결제 서비스를 통해서 이루어진다. ⑧ 결제 시 포인트를 사용할 수 있고, 사용한 포인트를 제외한 금액이 신용카드나 간편 결제 서비스에 청구된다. ⑨ 결제를 완료하면 예약이 완료된다. ⑩ 결제가 완료되면 사용자에게 포인트가 적립되고 메일이 발송된다. ⑪ 구매 목록에 신규 게임이 나타나고, "환불 요청" 버튼이 활성화된다. ⑫ "환불 요청“ 버튼을 누르면 예약과 결제가 동시에 취소된다. ⑬ 취소가 되면 사용자의 구매 목록에서 사라진다. ⑭ 환불을 진행하면 적립된 포인트도 차감이 된다. ⑮ 출시일이 되면 사용자는 다운로드가 가능해진다. ⑯ 출시일이 되면 예약 할인이 종료되고 정상가로 구매가 가능하다.

[업무 시나리오 2] - 선물하기 ① 사용자는 선물하기를 통하여 게임을 다른 사용자에게 선물할 수 있다. ② 기존에 구매한 제품은 선물이 불가하다. ③ 게임 상점 페이지에서 "선물로 구매"를 선택한다. ④ 선물은 친구 목록에 추가된 사용자에게만 가능하다. 친구 목록은 사전에 상대방의 승인을 통해서 등록한다. ⑤ 선물할 게임을 가지고 있는 친구는 친구 목록에 나타나지 않는다. ⑥ 선물할 친구가 포함되어 있지 않다면, 친구 추가 메뉴에서 추가한다. 시스템은 추가된 친구에게 메일을 발송한다. ⑦ 선물하기는 바로 보내기 또는 예약을 통하여 특정 날짜에 자동 전달이 될 수 있다. 이때 메시지를 작성할 수 있다. ⑧ 결제는 사용자의 국가에서 지원하는 결제 방식(신용카드/간편 결제 시스템)을 선택하여 결제한다. ⑨ 결제는 외부 업체를 통해서 처리한다. ⑩ 결제가 완료되면 친구에게 알림과 이메일이 발송된다. ⑪ 선물을 받은 사람이 “선물 수락”을 하면 게임을 다운로드 받게 된다. ⑫ 선물을 받은 사람이 “선물 거절”을 하면 보낸 사람에게 바로 환불 처리가 된다. ⑬ 친구가 30일 동안 수락하지 않으면 자동 환불 처리가 된다. ⑭ 선물한 내용은 리포팅 시스템에서 조회가 가능하다.

문제1. 업무 시나리오 1에서 예약 결제(⑤~⑪)와 환불 처리(⑫~⑭)에 대해, 아래 요건을 고려하여 필요한 API 기능을 정의하고, 실패 시 필요한 보상 트랜잭션에 대해서 정리하시오. (30점)
- 예약 결제와 환불 처리에 대해서 각각 작성
- 서비스는 1번 문제에서 도출한 서비스를 기반으로 작성(필요 시 추가 가능)
- 보상 트랜잭션의 호출이 최대한 적게 발생할 수 있도록 호출 순서 정의
- 트랜잭션 종류에 보상 가능 / 피봇 / 재시도 가능 트랜잭션 표기

----------------(참고/SAGA 트랜잭션 유형)------------------

보상 가능 트랜잭션:
설명: 실패하거나 취소될 경우, 원래 상태로 되돌릴 수 있는 트랜잭션입니다.
예시: 포인트 사용이나 예약 주문 취소 등, 실패 시 포인트를 돌려주거나 예약을 취소해 원래 상태로 되돌릴 수 있습니다.

피봇 트랜잭션:
설명: 시스템의 핵심 상태를 변경하며, 이 단계가 성공해야만 다음 단계로 진행할 수 있는 트랜잭션입니다. 실패 시 더 이상 다음 단계로 가지 않으며, 이 상태에서 보상 트랜잭션이 필요할 수도 있습니다.
예시: 결제 처리나 환불 요청 등, 이 단계에서 실패하면 다음 단계로 진행하지 않고, 필요시 보상 트랜잭션으로 상태를 되돌립니다.

재시도 가능 트랜잭션:
설명: 일시적인 오류로 인해 실패했을 경우 재시도할 수 있는 트랜잭션입니다. 주로 네트워크 문제나 외부 시스템의 일시적 문제로 인해 실패할 수 있는 경우에 사용됩니다.
예시: 외부 결제 시스템 호출이나 이메일 발송 등, 일시적인 실패가 있을 수 있지만 다시 시도하면 성공할 수 있는 작업입니다.

정리
보상 가능 트랜잭션: 실패 시 원래 상태로 되돌릴 수 있는 작업.
피봇 트랜잭션: 시스템의 핵심 상태를 변경하며, 성공 시 다음 단계로 넘어가고 실패 시 더 진행하지 않음.
재시도 가능 트랜잭션: 일시적 오류로 인해 실패할 경우, 다시 시도할 수 있는 작업.

----------------------------------

### 문제 1: 예약 결제 및 환불 처리에 대한 API 기능 정의 및 보상 트랜잭션 정리

#### 1. **예약 결제 API 정의**

예약 결제 프로세스에서는 다음과 같은 API와 트랜잭션을 고려해야 합니다:

1. **API 1: 예약 주문 생성**
   - **기능:** 사용자가 예약 주문을 생성합니다.
   - **트랜잭션 종류:** 피봇 트랜잭션 (예약 주문이 성공적으로 생성되면 다음 단계로 진행)
   - **실패 시 보상 트랜잭션:** N/A (실패 시 다음 단계로 진행되지 않음)

2. **API 2: 결제 정보 등록**
   - **기능:** 사용자가 결제할 정보를 등록하고 결제 요청을 합니다.
   - **트랜잭션 종류:** 피봇 트랜잭션 (결제 정보가 성공적으로 등록되면 다음 단계로 진행)
   - **실패 시 보상 트랜잭션:** 예약 주문 취소 (예약 주문 생성 API에서 생성된 주문을 취소)

3. **API 3: 포인트 사용 처리**
   - **기능:** 사용자가 사용할 포인트를 차감합니다.
   - **트랜잭션 종류:** 보상 가능 트랜잭션 (포인트 차감이 완료되면 결제 단계로 진행)
   - **실패 시 보상 트랜잭션:** 포인트 복구

4. **API 4: 결제 처리**
   - **기능:** 신용카드/간편 결제 서비스를 통해 결제를 완료합니다.
   - **트랜잭션 종류:** 피봇 트랜잭션 (결제가 성공적으로 완료되면 다음 단계로 진행)
   - **실패 시 보상 트랜잭션:** 예약 주문 취소 및 포인트 복구

5. **API 5: 주문 완료 처리**
   - **기능:** 결제가 성공적으로 완료된 후, 주문을 확정하고 포인트를 적립합니다.
   - **트랜잭션 종류:** 보상 가능 트랜잭션 (주문 확정 및 포인트 적립이 완료되면 예약이 완료됨)
   - **실패 시 보상 트랜잭션:** 포인트 복구, 결제 취소 (이전 단계에서 결제가 이루어졌다면)

#### 2. **환불 처리 API 정의**

환불 처리 프로세스에서는 다음과 같은 API와 트랜잭션을 고려해야 합니다:

1. **API 1: 환불 요청**
   - **기능:** 사용자가 환불 요청을 시작합니다.
   - **트랜잭션 종류:** 피봇 트랜잭션 (환불 요청이 성공적으로 접수되면 다음 단계로 진행)
   - **실패 시 보상 트랜잭션:** N/A (실패 시 다음 단계로 진행되지 않음)

2. **API 2: 포인트 차감**
   - **기능:** 예약 시 적립된 포인트를 차감합니다.
   - **트랜잭션 종류:** 보상 가능 트랜잭션 (포인트 차감이 완료되면 결제 환불 단계로 진행)
   - **실패 시 보상 트랜잭션:** 포인트 복구

3. **API 3: 결제 환불 처리**
   - **기능:** 신용카드/간편 결제 서비스를 통해 결제 환불을 완료합니다.
   - **트랜잭션 종류:** 피봇 트랜잭션 (환불이 성공적으로 처리되면 다음 단계로 진행)
   - **실패 시 보상 트랜잭션:** 포인트 복구

4. **API 4: 환불 완료 처리**
   - **기능:** 환불이 성공적으로 완료된 후, 예약을 취소하고 구매 목록에서 제거합니다.
   - **트랜잭션 종류:** 보상 가능 트랜잭션 (환불 완료 후 최종 확인)
   - **실패 시 보상 트랜잭션:** 포인트 복구 및 결제 재시도 가능

#### 3. **보상 트랜잭션 호출 순서**

보상 트랜잭션의 호출을 최소화하기 위해 각 트랜잭션을 순차적으로 실행하고, 다음 단계로 넘어가기 전에 각 단계의 성공 여부를 검증합니다. 예를 들어, 결제 처리 후 주문 완료 처리가 실패했을 경우, 주문 완료 처리에 대한 보상 트랜잭션(포인트 복구 및 결제 취소)을 수행해야 합니다.

1. **예약 결제 프로세스**
   - 예약 주문 생성 → 결제 정보 등록 → 포인트 사용 처리 → 결제 처리 → 주문 완료 처리

2. **환불 처리 프로세스**
   - 환불 요청 → 포인트 차감 → 결제 환불 처리 → 환불 완료 처리

각 트랜잭션의 실패는 이전 단계로 돌아가 필요한 보상 트랜잭션을 호출하는 방식으로 설계하여 시스템의 일관성을 유지하면서 보상 트랜잭션 호출을 최소화할 수 있습니다.

----------------- 추가 분석(Azure 구축) -----------------------

Azure 상에서 게임 판매 사이트를 구축하기 위해 제안할 수 있는 아키텍처와 리소스 구성을 설명드리겠습니다. 이 제안은 글로벌 서비스, 유연한 확장성, 고가용성, 데이터 보안 및 성능을 고려한 설계를 목표로 합니다.

1. Azure 아키텍처 개요
Frontend: 전 세계 사용자를 대상으로 하는 웹 애플리케이션.
Backend: 유연한 비즈니스 로직 처리와 데이터 관리.
Data Layer: 사용자의 행동 데이터와 게임 추천 시스템을 위한 데이터 관리.
Monitoring & Security: 시스템 상태 모니터링 및 보안 관리.
Global Distribution: 다양한 지역에서의 사용자 접속을 최적화하기 위한 분산 처리 및 콘텐츠 배포

3. 주요 Azure 리소스 구성

[Frontend (사용자 인터페이스)]

Azure Front Door:
전 세계 사용자에게 빠르고 안정적인 콘텐츠 전송을 위해 Azure Front Door를 사용해 글로벌 부하 분산 및 가속화를 구현합니다.
DDoS 보호 및 WAF(Web Application Firewall)로 보안을 강화합니다.

Azure App Service:
Frontend 웹 애플리케이션을 호스팅하기 위해 Azure App Service를 사용합니다. 이는 .NET, Node.js, Python 등 다양한 프레임워크를 지원하며, 수평적 확장이 용이합니다.

Azure CDN:
게임 이미지, 동영상, 다운로드 파일 등 정적 콘텐츠의 전 세계 배포를 위해 Azure CDN을 사용합니다.

[Backend (비즈니스 로직)]

Azure Kubernetes Service (AKS):
유연한 확장성을 위해 Azure Kubernetes Service에 비즈니스 로직을 컨테이너화하여 배포합니다. POC 단계에서 서비스 확장이 필요할 경우 빠르게 스케일업/스케일다운이 가능합니다.

Azure Functions:
서버리스 방식으로 사용자의 요청에 따라 자동으로 확장/축소되는 비즈니스 로직 처리(예: 예약 주문, 결제, 게임 추천)를 위한 이벤트 기반 작업을 처리합니다.

[Data Layer (데이터 관리)]

Azure SQL Database:
결제 정보, 사용자 계정, 게임 메타데이터 등 중요한 관계형 데이터를 관리하기 위해 Azure SQL Database를 사용합니다. 이는 고가용성과 자동 백업을 지원합니다.

Azure Cosmos DB:
글로벌 분산된 NoSQL 데이터베이스로 사용자 활동, SNS 데이터, 사용자 성향 분석 등 비관계형 데이터를 관리합니다.

Azure Cache for Redis:
빠른 데이터 접근이 필요한 경우(예: 실시간 채팅, 빠른 검색 결과 제공)를 위해 Azure Cache for Redis를 사용합니다.

[Analytics & Recommendations (분석 및 추천)]

Azure Synapse Analytics:
사용자 행동 및 SNS 데이터를 분석해 게임 추천을 제공하기 위해 Azure Synapse Analytics를 사용합니다. 빅데이터 분석을 위해 Azure Data Lake와 통합할 수 있습니다.

Azure Machine Learning:
사용자의 게임 성향을 분석하고 맞춤형 게임을 추천하기 위해 Azure Machine Learning을 사용해 모델을 학습하고 배포합니다.

[Monitoring & Security (모니터링 및 보안)]

Azure Monitor & Log Analytics:
애플리케이션의 성능, 상태, 트래픽을 실시간으로 모니터링하기 위해 Azure Monitor와 Log Analytics를 사용합니다.

Azure Security Center:
전반적인 보안 모니터링 및 위협 탐지를 위해 Azure Security Center를 사용합니다.

[Global Distribution (글로벌 분산 처리)]

Azure Traffic Manager:
사용자가 속한 지역에 따라 트래픽을 최적의 Azure 지역으로 라우팅하기 위해 Azure Traffic Manager를 사용합니다.

Azure Blob Storage:
글로벌 분산된 데이터 스토리지를 위해 Azure Blob Storage를 사용하여 게임 다운로드 파일 등을 저장합니다. Geo-redundant 스토리지 옵션을 통해 데이터의 고가용성을 보장합니다.

3. 서비스 흐름 예시
사용자가 웹사이트에 접속 → Azure Front Door가 사용자를 최적의 데이터센터로 연결 → Azure App Service에서 웹 페이지 제공 → 게임 예약 주문 시 Azure Functions에서 비즈니스 로직 처리 → Azure SQL Database에서 예약 정보 저장 및 처리 → Azure Cache for Redis에서 실시간 채팅 처리 → Azure Synapse Analytics에서 사용자 데이터 분석 및 추천 게임 제공 → Azure Machine Learning을 통해 추천 알고리즘 강화.

4. 보안 및 고가용성
보안: Azure Security Center와 WAF를 통해 시스템의 전반적인 보안을 강화하고, Azure AD B2C로 다양한 소셜 로그인 기능을 지원합니다.
고가용성: 각 서비스는 여러 지역에서 중복 배포하여 Azure Traffic Manager 및 Azure Load Balancer를 사용해 유연한 트래픽 관리를 수행합니다.

5. 비용 최적화 및 관리
Autoscaling: Azure의 자동 확장 기능을 통해 사용량에 따라 필요한 리소스만 사용하여 비용을 최적화합니다.
Azure Cost Management: 비용 관리를 위해 Azure Cost Management를 사용해 리소스 사용량과 비용을 실시간으로 모니터링합니다.
이 아키텍처는 전 세계 사용자를 대상으로 하는 고가용성, 확장성, 유연성을 모두 고려한 Azure 기반의 게임 판매 시스템을 설계하는 데 적합합니다.

--------
![image](https://github.com/user-attachments/assets/d6e092d3-539e-4093-88b0-a30d6ae75333)


-------------------------------

## 업무용 시스템의 이슈에 대한 일반적인 솔루션은 무엇일까?
"업무용 응용프로그램 개발 방안
 - A고객사 시스템의 채널 확대 및 사용자 증가에 따라 발생하는 인증 및 세션 관리 문제 해결을 위한 인증 방식 개선 방안
 - A고객사 비즈니스 유연성과 성능 관점에서 상품을 관리하기 위한 데이터 모델을 새롭게 설계하고 설계 사유 제시
 - 예약 처리 프로세스와 데이터 모델에서 발생하고 있는 동시성 이슈의 해결 방안 제시"

### 업무용 시스템의 이슈를 해결하기 위한 일반적인 솔루션

1. 인증 및 세션 관리 문제 해결을 위한 인증 방식 개선 방안
   - 솔루션:
      - OAuth 2.0 / OpenID Connect: 사용자 인증 및 세션 관리를 강화하기 위해 OAuth 2.0 또는 OpenID Connect 같은 표준 인증 프로토콜을 도입합니다. 이들은 확장성과 보안성을 높여주며, 소셜 로그인 기능을 쉽게 통합할 수 있습니다.
      - Multi-Factor Authentication (MFA): 사용자 인증 시 MFA를 도입하여 보안성을 높입니다. SMS, 이메일, 또는 전용 인증 앱을 통해 추가 인증을 요구합니다.
      - Token-Based Authentication: 세션 상태를 서버에 저장하지 않고, 클라이언트에게 발급된 JWT(JSON Web Token)를 통해 인증 상태를 유지합니다. 이는 서버 부하를 줄이고 확장성을 높이는 데 도움이 됩니다.

2. 상품을 관리하기 위한 데이터 모델 설계
   - 솔루션:
      - 유연한 데이터 모델 설계: 상품 관리의 비즈니스 유연성을 위해 데이터 모델을 유연하게 설계합니다. 예를 들어, 각 상품을 독립된 엔터티로 관리하며, 상품 속성을 Key-Value Store처럼 동적으로 확장할 수 있는 구조로 설계합니다.
      - 마이크로서비스 아키텍처: 상품 관리 시스템을 독립적인 마이크로서비스로 분리하여 개발합니다. 이를 통해 각 상품 관련 기능을 독립적으로 배포하고 확장할 수 있습니다.
      - NoSQL 데이터베이스: 상품의 다양한 속성 및 구조적 유연성을 제공하기 위해 NoSQL 데이터베이스(Cassandra, MongoDB 등)를 사용하여 데이터 모델을 설계합니다.

3. 동시성 이슈 해결 방안
   - 솔루션:
      - 낙관적 락(Optimistic Locking): 데이터 업데이트 시 충돌 가능성을 줄이기 위해 낙관적 락을 적용합니다. 각 레코드에 버전 번호를 두어 업데이트 시점에 데이터가 변경되지 않았음을 확인합니다.
      - Pessimistic Locking: 중요한 예약 처리 프로세스에서 데이터 충돌을 방지하기 위해 비관적 락을 사용합니다. 이를 통해 트랜잭션이 완료되기 전까지 데이터를 잠궈 다른 트랜잭션에서 접근하지 못하게 합니다.
      - 큐잉 시스템: 예약 처리에서 동시성 문제를 해결하기 위해 큐잉 시스템을 도입합니다. 이를 통해 예약 요청을 순차적으로 처리할 수 있어 동시성 이슈를 완화할 수 있습니다.
      - 분산 락 매니저: Redis와 같은 분산 락 매니저를 사용하여 여러 서버 간에 동시성 제어를 할 수 있습니다.

이와 같은 솔루션을 통해 A고객사의 시스템에서 발생하는 인증 및 세션 관리 문제, 데이터 모델 유연성, 그리고 동시성 이슈를 효과적으로 해결할 수 있습니다.


### <Azure 기반으로 A 고객사의 시스템 이슈를 해결하기 위한 솔루션>

1. 인증 및 세션 관리 문제 해결을 위한 인증 방식 개선
   - Azure Active Directory (Azure AD) B2C:
      - 설명: Azure AD B2C는 클라우드 기반의 ID 및 접근 관리 솔루션입니다. 이를 통해 사용자는 OAuth 2.0 및 OpenID Connect를 기반으로 하여 보안성 높은 인증을 수행할 수 있습니다.
      - 솔루션:
         - 다중 인증 (MFA): Azure AD B2C를 통해 사용자 인증 시 MFA를 쉽게 도입할 수 있습니다. SMS, 이메일, 또는 전용 인증 앱을 통한 추가 인증을 요구하여 보안을 강화합니다.
         - 소셜 로그인: Azure AD B2C는 다양한 소셜 로그인(예: Google, Facebook)을 쉽게 통합하여 사용자 가입 절차를 간소화합니다.
         - 정책 기반 인증: Azure AD B2C의 정책을 활용하여 특정 조건에 맞는 사용자에게 맞춤형 인증 경험을 제공할 수 있습니다.
   - Azure Front Door와 Azure Application Gateway:
      - 설명: Azure Front Door와 Azure Application Gateway는 전역적인 애플리케이션 전달 및 부하 분산 서비스입니다.
      - 솔루션:
         - 세션 지속성: Azure Front Door를 활용하여 사용자 요청을 효율적으로 라우팅하며, 전역적인 세션 지속성을 유지할 수 있습니다.
         - WAF (웹 애플리케이션 방화벽): Azure Application Gateway의 WAF 기능을 사용하여 인증 요청을 포함한 웹 애플리케이션을 보호할 수 있습니다.

2. 상품 관리를 위한 데이터 모델 설계
   - Azure Cosmos DB:
      - 설명: Azure Cosmos DB는 전역적으로 분산된 NoSQL 데이터베이스로, 높은 확장성과 저지연성을 제공합니다.
      - 솔루션:
         - 유연한 데이터 모델: 상품의 속성을 동적으로 추가할 수 있는 유연한 데이터 모델을 지원합니다. JSON 형태로 데이터를 저장하여 다양한 구조의 데이터를 처리할 수 있습니다.
         - 지리적 분산: Cosmos DB는 지리적으로 분산된 데이터베이스를 제공하여 글로벌 사용자에게 낮은 지연 시간을 보장할 수 있습니다.
         - 자동 확장성: 트래픽 증가에 따라 자동으로 확장되어, 급격한 사용자 증가에도 안정적인 서비스를 제공합니다.
   - Azure Functions:
      - 설명: Azure Functions는 서버리스 컴퓨팅 서비스로, 이벤트 기반의 확장 가능한 애플리케이션을 구축할 수 있습니다.
      - 솔루션:
         - 상품 업데이트: 상품 정보가 변경될 때마다 Azure Functions를 트리거로 사용하여 관련된 작업(예: 가격 변경, 재고 업데이트)을 자동으로 처리합니다.
         - 비동기 처리: 예약 및 결제 요청을 비동기로 처리하여 시스템 성능을 최적화할 수 있습니다.

3. 동시성 이슈 해결 방안
   - Azure Service Bus:
      - 설명: Azure Service Bus는 안정적인 메시지 큐잉 서비스로, 비동기 작업을 효율적으로 처리할 수 있습니다.
      - 솔루션:
         - 예약 처리 큐: 예약 처리와 같은 동시성 이슈가 발생할 수 있는 작업을 큐로 처리하여, 순차적으로 작업을 진행할 수 있습니다.
         - 메시지 재처리: 실패한 메시지는 DLQ(Dead Letter Queue)로 전달되어 재처리할 수 있는 메커니즘을 제공합니다.
       
   - Azure SQL Database with In-Memory OLTP:
      - 설명: Azure SQL Database는 클라우드에서 완전 관리되는 SQL 데이터베이스 서비스입니다.
      - 솔루션:
         - In-Memory OLTP: 동시성 높은 트랜잭션을 위해 Azure SQL Database의 In-Memory OLTP 기능을 활용하여 처리 성능을 극대화할 수 있습니다.
         - 분산 락 관리: 데이터베이스 내에서의 동시성 관리를 위해 락을 사용하지만, In-Memory OLTP를 통해 락 경합을 줄여 성능을 향상시킵니다.

이와 같은 Azure 기반의 솔루션을 도입하면 A 고객사의 인증 및 세션 관리, 상품 관리 데이터 모델의 유연성, 그리고 동시성 이슈를 효과적으로 해결할 수 있습니다.

test push
